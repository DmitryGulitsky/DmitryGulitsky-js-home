<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Изменение текстового содержимого элементов </title>
</head>
<body>
<!-- На уровне HTML описан <div> с красным кружком, который будет точкой отсчёта — у него чётко заданы координаты.
 Заметьте, чтобы получить кружок, <div> сделан квадратным с border-radius: 50%, это часто используемый приём. -->
<div id='RED' style='position: absolute; width: 50px; height: 50px;
        left: 200px; top: 400px; background-color: red; border-radius: 50%'></div>
<!-- На уровне HTML также описан <div> с зелёным кружком, который не спозиционирован никуда
(мы его будем позиционировать программно), но для него задано position: absolute,
чтобы позиционирование вообще сработало. -->
<div id='GREEN' style='position: absolute; width: 20px; height: 20px;
      background-color: green; border-radius: 50%'></div>

<!-- Также описана форма с полями для расстояния и угла, в ней заданы начальные значения. Заметьте, если отправка
 формы на сервер не требуется, тег <form> вообще необязателен, но тогда бы пришлось искать поля
 формы через getElementById. -->
<form name=FPos>
  Расстояние (радиус): <input type=text name=Radius value='100'><br/>
  Угол (в градусах): <input type=text name=Angle value='30'><br/>
  <input type=button value='позиционировать' onclick='Pos()'>
</form>

<script>

  function Pos() {
    // Собственно функция позиционирования. Она должна прочитать из формы расстояние и угол, и
    // спозиционировать зелёный кружок на этом расстоянии под этим углом от красного кружка.

    //      Находим оба кружочка.
    var Red = document.getElementById('RED');
    var Green = document.getElementById('GREEN');
    //      Находим саму форму.
    var Form = document.forms.FPos;

    //      Читаем строковое значение, введённое в поле "Расстояние", и преобразуем его к числу.
    var Radius = parseFloat(Form.elements.Radius.value);

    //      Читаем строковое значение, введённое в поле "Угол", и преобразуем его к числу.
    // В поле вводится угол в градусах, а нам в расчётах потребуется угол в радианах, поэтому
    // сразу делим его на 180 и умножаем на "пи".
    //      Итак, в переменной Radius у нас расстояние, а в переменной Angle — угол в радианах,
    // на которые надо сместить зелёный кружок относительно красного.

    var Angle = parseFloat(Form.elements.Angle.value) / 180 * Math.PI;

    //      Получим координаты ЦЕНТРА красного кружка. Обращаем внимание, в DOM координаты элемента —
    // это координаты его левого верхнего угла, но в расчётах нам удобнее оперировать ЦЕНТРОМ красного кружка.
    // Координаты центра — это координаты левого верхнего угла плюс половина ширины и половина высоты.
    var RedCenterX = Red.offsetLeft + Red.offsetWidth / 2;
    var RedCenterY = Red.offsetTop + Red.offsetHeight / 2;

    /* Очень важно понять, что формулы для расчёта положения объекта на заданном расстоянии под
    заданном углом от точки отсчёта вариабельны — ВАМ РЕШАТЬ, где у вас будет угол 0 (справа, сверху, слева, снизу)
    и куда будет отсчитывается угол (по часовой стрелке или против часовой), математически это зависит от операции
    (плюс или минус) в первой формуле, операции (плюс или минус) во второй формуле, и комбинации тригонометрических
    функций (в первой формуле синус и во второй косинус или наоборот). Если вы реализуете стреляющее вправо ружьё —
    вам удобнее чтобы угол 0 был справа и угол отсчитывался против часовой стрелки; если реализуете часы — удобнее
    чтобы угол 0 был сверху и угол отсчитывался по часовой стрелке. Если вы неудачно выберете угол 0 и направление
    отсчёта — возможности кода не сужаются, но вам придётся писать более громоздкие формулы, код будет менее понятен
     и хуже сопровождаться.
    В данной формуле случае угол 0 — сверху, и угол отсчитывается по часовой стрелке.*/

    var GreenCenterX = RedCenterX + Radius * Math.sin(Angle);
    var GreenCenterY = RedCenterY - Radius * Math.cos(Angle);

    /*Мы рассчитали координаты ЦЕНТРА зелёного кружка, но позиционируем же мы стилевыми свойствами left и top
    не центр кружка, а его левый верхний угол. Спозиционируем зелёный кружок, теперь уже вычьтя из координат
    центра половину ширины и высоты.
    При присваивании значений стилевым свойствам left и top не забываем указывать единицу измерения.
    Выше, offsetLeft и offsetTop вернули положение красного кружка в пикселях, поэтому и рассчитанные здесь
    координаты зелёного кружка — именно координаты в пикселях.
    */
    Green.style.left = Math.round(GreenCenterX - Green.offsetWidth / 2) + 'px';
    Green.style.top = Math.round(GreenCenterY - Green.offsetHeight / 2) + 'px';
  }

  Pos();

</script>
</body>
</html>